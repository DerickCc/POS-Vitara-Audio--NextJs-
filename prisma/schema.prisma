generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  // Uses connection pooling
  url       = env("POSTGRES_PRISMA_URL")
  // Uses direct connection, ⚠️ make sure to keep this to `POSTGRES_URL_NON_POOLING`
  // or you'll have dangling databases from migrations
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model Users {
  id            String    @id @default(cuid())
  name          String    @db.VarChar(50)
  username      String    @unique @db.VarChar(50)
  password      String
  accountStatus Boolean   @default(true)
  role          String    @db.VarChar(20)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime? @updatedAt

  CreatedCustomer Customers[]
  UpdatedCustomer Customers[] @relation("UpdatedByUser")

  CreatedSupplier Suppliers[]
  UpdatedSupplier Suppliers[] @relation("UpdatedByUser")

  CreatedProduct Products[]
  UpdatedProduct Products[] @relation("UpdatedByUser")

  CreatedPuchaseOrders PuchaseOrders[]
  UpdatedPuchaseOrders PuchaseOrders[] @relation("UpdatedByUser")
}

model Customers {
  id           String  @id @default(cuid())
  code         String  @unique @db.VarChar(11)
  name         String  @db.VarChar(100)
  licensePlate String  @db.VarChar(20)
  phoneNo      String  @db.VarChar(20)
  address      String? @db.VarChar(100)

  CreatedBy Users    @relation(fields: [createdBy], references: [id], onUpdate: Cascade, onDelete: Restrict)
  createdBy String
  createdAt DateTime @default(now())

  UpdatedBy Users?    @relation("UpdatedByUser", fields: [updatedBy], references: [id], onUpdate: Cascade, onDelete: Restrict)
  updatedBy String?
  updatedAt DateTime? @updatedAt

  @@index([code, name, licensePlate, phoneNo, address])
}

model Suppliers {
  id               String  @id @default(cuid())
  code             String  @unique @db.VarChar(11)
  name             String  @db.VarChar(100)
  pic              String  @db.VarChar(20)
  phoneNo          String  @db.VarChar(20)
  address          String? @db.VarChar(100)
  remarks          String? @db.VarChar(250)
  receivables      Int     @default(0) @db.Integer()
  receivablesLimit Int     @default(0) @db.Integer()

  PuchaseOrders PuchaseOrders[]

  CreatedBy Users    @relation(fields: [createdBy], references: [id], onUpdate: Cascade, onDelete: Restrict)
  createdBy String
  createdAt DateTime @default(now())

  UpdatedBy Users?    @relation("UpdatedByUser", fields: [updatedBy], references: [id], onUpdate: Cascade, onDelete: Restrict)
  updatedBy String?
  updatedAt DateTime? @updatedAt

  @@index([code, name, pic, phoneNo, address, receivables])
}

model Products {
  id               String  @id @default(cuid())
  code             String  @unique @db.VarChar(11)
  name             String  @db.VarChar(100)
  photo            String? @db.VarChar(100)
  stock            Decimal @db.Decimal(10, 2)
  restockThreshold Decimal @db.Decimal(10, 2)
  uom              String  @db.VarChar(50)
  costPrice        Int     @db.Integer()
  costPriceCode    String  @db.VarChar(50)
  purchasePrice    Int     @db.Integer()
  sellingPrice     Int     @db.Integer()
  remarks          String? @db.VarChar(250)

  CreatedBy Users    @relation(fields: [createdBy], references: [id], onUpdate: Cascade, onDelete: Restrict)
  createdBy String
  createdAt DateTime @default(now())

  UpdatedBy Users?    @relation("UpdatedByUser", fields: [updatedBy], references: [id], onUpdate: Cascade, onDelete: Restrict)
  updatedBy String?
  updatedAt DateTime? @updatedAt

  @@index([code, name, stock, uom])
}

model PuchaseOrders {
  id           String   @id @default(cuid())
  poCode       String   @unique @db.VarChar(11)
  purchaseDate DateTime @default(now())
  supplierId   String
  remarks      String?  @db.VarChar(250)
  totalItem    Int      @db.Integer()
  totalPrice   Int      @db.Integer()
  status       String   @db.VarChar(50)

  Supplier Suppliers @relation(fields: [supplierId], references: [id], onUpdate: Cascade, onDelete: Restrict)

  CreatedBy Users    @relation(fields: [createdBy], references: [id], onUpdate: Cascade, onDelete: Restrict)
  createdBy String
  createdAt DateTime @default(now())

  UpdatedBy Users?    @relation("UpdatedByUser", fields: [updatedBy], references: [id], onUpdate: Cascade, onDelete: Restrict)
  updatedBy String?
  updatedAt DateTime? @updatedAt
}
